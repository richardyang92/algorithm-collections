### 1. 什么是归并算法

顾名思义，归并排序是一种排序算法。它的作用是将一个大小有限的数组按从小到大的顺序排列整齐。所谓“归并”是指将两个或者多个较小的数组合并成一个较大的数组的过程。如果归并过程中，我们总是遵循将较小的元素放入左边的数组而较大的元素放入右边的数组的原则，那么就能很容易的实现数组的排序了。

### 2. 归并怎样进行

那么“归并”是如何进行的呢？我们从最简单的情况开始讲起。两个数组$a=[1,3,5,7]$和$b=[2,4,6,8]$，它们本身都已经按升序排列且$b$中每一个元素都比$a$中对应位置的元素大。在这种情况下，仅需要依次从$a$和$b$中取元素放入结果数组中就能完成“归并”操作了，用代码表示如下：

```C
int a[4] = { 1, 3, 5, 7 };
int b[4] = { 2, 4, 6, 8 };

int arr[8] = { 0 };

void merge(int* arr, int* a, int *b) {
    for (int i = 0; i < 4; i++) {
        arr[i] = a[i];
        arr[i + 1] = b[i];
    }
}
```

接下来，我们增加一下难度，将$a$和$b$中一些元素做调换，使得$b$中每一个元素不一定比$a$中对应位置的元素大。现在设$a=[1,4,6,7]$和$b=[2,3,5,8]$，显然我们不能再简单的将元素依次填进结果数组里面去了。正确的做法是每次填入一个元素之前需要确定应该填入$a$中的元素还是$b$中的元素。用算法表示如下：

```C
int a[4] = { 1, 3, 5, 7 };
int b[4] = { 2, 4, 6, 8 };

int arr[8] = { 0 };

void merge(int* arr, int* a, int *b) {
    int i = 0, j = 0, k = 0;
    while (i < 4 && j < 4) {
        if (a[i] <= b[j]) {
            arr[k++] = a[i++];
        } else {
            arr[k++] = b[j++];
        }
    }
}
```

上述算法只能工作在数组$a$和$b$等长的情形下，我们期待的是算法能处理说有可能的情形。所以，我们在增加一些难度，让数组$a$和$b$不等长：设$a=[1,4,6,7,9,10]$和$b=[2,3,5,8,11]$（这里给数组$a$和$b$加上一个限制，虽然不等长但是较小的数总是存放在$a$中而较大的数则存放在$b$中）。相应的算法修改如下：

```C
int a[6] = { 1, 3, 5, 7, 9, 10 };
int b[5] = { 2, 4, 6, 8, 11 };

int arr[11] = { 0 };

void merge(int* arr, int* a, int *b) {
    int i = 0, j = 0, k = 0;
    while (i < 6 && j < 5) {
        if (a[i] <= b[j]) {
            arr[k++] = a[i++];
        } else {
            arr[k++] = b[j++];
        }
    }
    
    while (i < 6) {
        arr[k++] = a[i];
    }
    
    while (j < 5) {
        arr[k++] = b[j];
    }
}
```

### 3. 用分治思想进行归并

实际上的排序操作中是不可能直接提供已经按升序排列好的数组进行“归并”操作的，我们处理的一定是随机的、杂乱无章排列的数据。为了应用归并，我们需要首先将数组一分为二，并对分出的两个数组做“归并”操作。由于这两个数组一般不满足归并的条件，所以一个自然的想法是对这两个数组分别做一分为二的操作，并依次对分出的数组做此操作，直到分出的数组满足归并要求为止。在计算机中，这种操作是一种典型的递归过程，因此最终算法可用递归表达如下：

```C
void merge(int* arr, int p, int q, int r) {
    int m = p;
    int n = r + 1;
    int k = 0;
    int tmp[N] = {};

    while (m <= r && n <= q) {
        if (arr[m] <= arr[n]) {
            tmp[k++] = arr[m++];
        } else {
            tmp[k++] = arr[n++];
        }
    }

    while (m <= r) {
        tmp[k++] = arr[m++];
    }

    while (n <= q) {
        tmp[k++] = arr[n++];
    }

    for (int i = 0; i <= q - p; i++) {
        arr[p + i] = tmp[i];
    }
}

void mergeSort(int* arr, int p, int q) {
    if (p < q) {
        int r = (p + q) / 2;
        mergeSort(arr, p, r);
        mergeSort(arr, r + 1, q);
        merge(arr, p, q, r);
    }
}
```

